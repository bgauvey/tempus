@page "/calendar"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using Tempus.Core.Interfaces
@using Tempus.Core.Models
@using Tempus.Core.Enums
@using Tempus.Web.Components.Dialogs
@using Tempus.Web.Components.Dialogs.Events
@using Tempus.Web.Components.Shared
@using Tempus.Web.Services
@using Tempus.Web.Helpers
@using Microsoft.JSInterop
@attribute [Authorize]
@inject IEventRepository EventRepository
@inject ICalendarRepository CalendarRepository
@inject ICalendarSharingService CalendarSharingService
@inject ITeamService TeamService
@inject ISettingsService SettingsService
@inject DialogService DialogService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject Tempus.Web.Components.Account.IdentityUserAccessor IdentityUserAccessor
@inject IPdfAgendaService PdfAgendaService
@inject IJSRuntime JSRuntime
@inject IEmailNotificationService EmailNotificationService
@inject ContextMenuService ContextMenuService
@inject ITimeZoneConversionService TimeZoneConversionService
@inject NotificationService NotificationService
@inject ILogger<Calendar> Logger

<PageTitle>Calendar - Tempus</PageTitle>

<style>
    /* Calendar Page Layout */
    .calendar-page-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 80px); /* Subtract header height */
        overflow: hidden;
    }

    .calendar-header-section {
        flex-shrink: 0;
    }

    .calendar-templates-section {
        flex-shrink: 0;
    }

    .calendar-main-section {
        flex: 1;
        display: flex;
        flex-direction: row;
        gap: 1rem;
        min-height: 0; /* Important for flex children */
        overflow: hidden;
    }

    .calendar-sidebar {
        flex-shrink: 0;
        width: 280px;
        overflow-y: auto;
    }

    .calendar-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
        overflow: hidden;
    }

    .calendar-scheduler-card {
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    .calendar-scheduler-card .rz-card-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* Make RadzenScheduler fill available space */
    .calendar-scheduler-card .rz-scheduler {
        height: 100% !important;
        min-height: 500px;
    }

    .calendar-scheduler-card .rz-scheduler .rz-scheduler-content {
        height: calc(100% - 60px) !important; /* Subtract scheduler header */
    }

    /* Calendar Styling */
    .loading-container {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 400px;
    }

    :root {
        --transition-smooth: all 0.3s ease-in-out;
    }

    /* Time Block Templates */
    .template-buttons-container {
        border-radius: 16px;
        padding: 1.5rem;
        margin-bottom: 2rem;
        animation: fadeInUp 0.6s ease-out 0.15s backwards;
    }

    .template-buttons-title {
        font-size: 1.1rem;
        font-weight: 700;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .template-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.25);
        border-radius: 10px;
        font-weight: 600;
        transition: var(--transition-smooth);
        padding: 10px 16px;
        font-size: 0.85rem;
    }

    .template-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.35);
    }

    .template-btn.deep-work {
        background: linear-gradient(135deg, #8E24AA 0%, #6A1B9A 100%);
    }

    .template-btn.meeting {
        background: linear-gradient(135deg, #1E88E5 0%, #1565C0 100%);
    }

    .template-btn.break {
        background: linear-gradient(135deg, #43A047 0%, #2E7D32 100%);
    }

    .template-btn.focus {
        background: linear-gradient(135deg, #FB8C00 0%, #EF6C00 100%);
    }

    /* Calendar Sidebar */
    .calendar-item {
        border-radius: 8px;
        cursor: pointer;
        transition: var(--transition-smooth);
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .calendar-item:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }

    .calendar-color-indicator {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        flex-shrink: 0;
    }

    .calendar-item-name {
        flex: 1;
        font-weight: 500;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .calendar-item-hidden {
        opacity: 0.5;
    }
</style>

<div class="calendar-page-container">

<div class="calendar-header-section">
    <RadzenCard Style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 16px; padding: 2rem; box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); margin-bottom: 2rem;">
        <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.SpaceBetween" AlignItems="AlignItems.Center" Gap="1rem">
            <RadzenText TextStyle="TextStyle.DisplayH4" Style="font-weight: 800; margin: 0;">ðŸ“… Calendar</RadzenText>
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.5rem">
                <RadzenButton Icon="event_available"
                            ButtonStyle="ButtonStyle.Secondary"
                            Click="OpenCalendarManagement"
                            Size="ButtonSize.Medium"
                            Text="Manage Calendars"
                            title="Manage your calendars" />
                <RadzenButton Icon="schedule"
                            ButtonStyle="ButtonStyle.Primary"
                            Click="OpenFindTimeDialog"
                            Size="ButtonSize.Medium"
                            Text="Find Time"
                            title="Find optimal meeting times" />
                <RadzenButton Icon="@(_selectionMode ? "check_box" : "check_box_outline_blank")"
                            ButtonStyle="@(_selectionMode ? ButtonStyle.Warning : ButtonStyle.Secondary)"
                            Click="ToggleSelectionMode"
                            Size="ButtonSize.Medium"
                            Text="@(_selectionMode ? "Exit Selection" : "Select Events")"
                            title="Toggle event selection mode" />
                <RadzenButton Icon="search" ButtonStyle="ButtonStyle.Info" Click="OpenAdvancedSearch" Size="ButtonSize.Medium" Text="Advanced Search" title="Advanced search and filtering" />
                <RadzenButton Icon="picture_as_pdf" ButtonStyle="ButtonStyle.Success" Click="DownloadDailyAgenda" Size="ButtonSize.Medium" Text="Day Agenda" title="Download daily agenda as PDF" />
                @if (_isSearchActive)
                {
                    <RadzenButton Icon="clear" ButtonStyle="ButtonStyle.Warning" Click="ClearSearch" Size="ButtonSize.Medium" Text="Clear Search" title="Show all events" />
                }
            </RadzenStack>
        </RadzenStack>
    </RadzenCard>
</div>

@if (_selectedEventIds.Any())
{
    <div class="calendar-bulk-section">
        <BulkOperationsToolbar SelectedCount="@_selectedEventIds.Count"
                             OnClearSelection="@ClearSelection"
                             OnShowBulkDialog="@OpenBulkActionsDialog"
                             OnBulkComplete="@BulkComplete"
                             OnBulkDelete="@ConfirmBulkDelete" />
    </div>
}

<div class="calendar-templates-section">
    <RadzenCard Style="margin-bottom: 2rem;">
        <RadzenStack Gap="1rem">
            <RadzenText TextStyle="TextStyle.H6" Style="font-weight: 700;">âš¡ Quick Time Block Templates</RadzenText>
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.75rem" Wrap="FlexWrap.Wrap">
                <RadzenButton Click="@(() => CreateFromTemplate("Deep Work", 120))" class="template-btn deep-work" Size="ButtonSize.Small">
                    ðŸ§  Deep Work (2h)
                </RadzenButton>
                <RadzenButton Click="@(() => CreateFromTemplate("Meeting", 30))" class="template-btn meeting" Size="ButtonSize.Small">
                    ðŸ‘¥ Meeting (30m)
                </RadzenButton>
                <RadzenButton Click="@(() => CreateFromTemplate("Focus Block", 90))" class="template-btn focus" Size="ButtonSize.Small">
                    ðŸŽ¯ Focus Block (1.5h)
                </RadzenButton>
                <RadzenButton Click="@(() => CreateFromTemplate("Break", 15))" class="template-btn break" Size="ButtonSize.Small">
                    â˜• Break (15m)
                </RadzenButton>
                <RadzenButton Click="@(() => CreateFromTemplate("Planning", 60))" class="template-btn" Size="ButtonSize.Small">
                    ðŸ“‹ Planning (1h)
                </RadzenButton>
                <RadzenButton Click="@(() => CreateFromTemplate("Review", 45))" class="template-btn" Size="ButtonSize.Small">
                    âœ… Review (45m)
                </RadzenButton>
            </RadzenStack>
        </RadzenStack>
    </RadzenCard>
</div>

<div class="calendar-main-section">
    <!-- Calendar Sidebar -->
    <div class="calendar-sidebar">
        <RadzenCard Style="height: 100%;">
            <RadzenStack Gap="1rem">
                <RadzenText TextStyle="TextStyle.H6" Style="font-weight: 700; margin: 0;">My Calendars</RadzenText>

                @foreach (var calendar in _calendars.OrderBy(c => c.SortOrder))
                {
                    <div class="calendar-item @(calendar.IsVisible ? "" : "calendar-item-hidden")">
                        <div class="calendar-color-indicator" style="background-color: @calendar.Color;"></div>
                        <div class="calendar-item-name">@calendar.Name</div>
                        <RadzenCheckBox @bind-Value="@calendar.IsVisible"
                                      Change="@((bool value) => UpdateCalendarVisibility(calendar, value))" />
                    </div>
                }

                @if (!_calendars.Any())
                {
                    <RadzenText TextStyle="TextStyle.Body2" Style="color: var(--rz-text-secondary-color);">
                        No calendars found
                    </RadzenText>
                }

                @if (_sharedCalendars.Any())
                {
                    <hr style="border: none; border-top: 1px solid var(--rz-border-color); margin: 0.5rem 0;" />
                    <RadzenText TextStyle="TextStyle.H6" Style="font-weight: 700; margin: 0;">Shared Calendars</RadzenText>

                    @foreach (var share in _sharedCalendars)
                    {
                        var calendar = share.Calendar;
                        var displayColor = share.Color ?? calendar?.Color ?? "#3498db";
                        var displayName = calendar?.Name ?? "Unknown Calendar";

                        <div class="calendar-item @(share.IsVisible ? "" : "calendar-item-hidden")">
                            <div class="calendar-color-indicator" style="background-color: @displayColor;"></div>
                            <div class="calendar-item-name" title="Shared by @(share.SharedByUser?.UserName ?? "Unknown")">
                                @displayName
                            </div>
                            <RadzenCheckBox @bind-Value="@share.IsVisible"
                                          Change="@((bool value) => UpdateSharedCalendarVisibility(share, value))" />
                        </div>
                    }
                }

                @if (_teamMembers.Any())
                {
                    <hr style="border: none; border-top: 1px solid var(--rz-border-color); margin: 0.5rem 0;" />
                    <RadzenText TextStyle="TextStyle.H6" Style="font-weight: 700; margin: 0;">Team Members</RadzenText>

                    @foreach (var member in _teamMembers)
                    {
                        var displayName = $"{member.User?.FirstName} {member.User?.LastName}".Trim();
                        if (string.IsNullOrWhiteSpace(displayName))
                        {
                            displayName = member.User?.Email ?? "Unknown";
                        }

                        <div class="calendar-item @(_selectedTeamMemberIds.Contains(member.UserId) ? "" : "calendar-item-hidden")">
                            <div class="calendar-color-indicator" style="background-color: #9b59b6;"></div>
                            <div class="calendar-item-name" title="@member.Team?.Name">
                                @displayName
                            </div>
                            <RadzenCheckBox Value="@_selectedTeamMemberIds.Contains(member.UserId)"
                                          Change="@((bool value) => ToggleTeamMemberSelection(member.UserId, value))" />
                        </div>
                    }
                }
            </RadzenStack>
        </RadzenCard>
    </div>

    <!-- Calendar Content -->
    <div class="calendar-content">
        @if (_selectedTeamMemberIds.Any())
        {
            <!-- Side-by-side comparison view -->
            <div style="display: flex; gap: 1rem; overflow-x: auto;">
                <!-- Own Calendar -->
                <div style="flex: 1; min-width: 600px;">
                    <RadzenCard>
                        <RadzenText TextStyle="TextStyle.H6" Style="margin-bottom: 0.5rem;">My Calendar</RadzenText>
                        @if (_loading)
                        {
                            <div class="loading-container">
                                <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.Medium" />
                            </div>
                        }
                        else
                        {
                            <RadzenScheduler @ref="_scheduler" TItem="AppointmentData" Data="@_appointments"
                                       StartProperty="Start" EndProperty="End" TextProperty="Text"
                                       SelectedIndex="@_selectedViewIndex"
                                       AppointmentSelect="@OnAppointmentSelect"
                                       SlotSelect="@OnSlotSelect"
                                       SlotRender="@OnSlotRender"
                                       AppointmentRender="@OnAppointmentRender"
                                       AppointmentMove="@OnAppointmentMove"
                                       LoadData="@OnLoadData"
                                       @oncontextmenu:preventDefault
                                       Style="height: 600px;">
                                <ChildContent>
                                    <RadzenMonthView />
                                    <RadzenWeekView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                                    <RadzenDayView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                                    <RadzenYearView />
                                    <RadzenYearPlannerView />
                                    <RadzenYearTimelineView />
                                </ChildContent>
                            </RadzenScheduler>
                        }
                    </RadzenCard>
                </div>

                <!-- Team Member Calendars -->
                @foreach (var userId in _selectedTeamMemberIds)
                {
                    var member = _teamMembers.FirstOrDefault(m => m.UserId == userId);
                    var memberName = GetMemberDisplayName(member);
                    var memberAppointments = GetTeamMemberAppointments(userId);

                    <div style="flex: 1; min-width: 600px;">
                        <RadzenCard>
                            <RadzenText TextStyle="TextStyle.H6" Style="margin-bottom: 0.5rem;">@memberName</RadzenText>
                            @if (_loading)
                            {
                                <div class="loading-container">
                                    <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.Medium" />
                                </div>
                            }
                            else
                            {
                                <RadzenScheduler TItem="AppointmentData" Data="@memberAppointments"
                                           StartProperty="Start" EndProperty="End" TextProperty="Text"
                                           SelectedIndex="@_selectedViewIndex"
                                           AppointmentSelect="@OnTeamMemberAppointmentSelect"
                                           LoadData="@((args) => OnTeamMemberLoadData(args, userId))"
                                           Style="height: 600px;">
                                    <ChildContent>
                                        <RadzenMonthView />
                                        <RadzenWeekView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                                        <RadzenDayView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                                        <RadzenYearView />
                                        <RadzenYearPlannerView />
                                        <RadzenYearTimelineView />
                                    </ChildContent>
                                </RadzenScheduler>
                            }
                        </RadzenCard>
                    </div>
                }
            </div>
        }
        else
        {
            <!-- Single calendar view -->
            <RadzenCard class="calendar-scheduler-card">
                @if (_loading)
                {
                    <div class="loading-container">
                        <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.Large" />
                    </div>
                }
                else
                {
                    <RadzenScheduler @ref="_scheduler" TItem="AppointmentData" Data="@_appointments"
                           StartProperty="Start" EndProperty="End" TextProperty="Text"
                           SelectedIndex="@_selectedViewIndex"
                           AppointmentSelect="@OnAppointmentSelect"
                           SlotSelect="@OnSlotSelect"
                           SlotRender="@OnSlotRender"
                           AppointmentRender="@OnAppointmentRender"
                           AppointmentMove="@OnAppointmentMove"
                           LoadData="@OnLoadData"
                           @oncontextmenu:preventDefault>
                <ChildContent>
                    <RadzenMonthView />
                    <RadzenWeekView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                    <RadzenDayView StartTime="@TimeSpan.FromHours(0)" EndTime="@TimeSpan.FromHours(24)" />
                    <RadzenYearView />
                    <RadzenYearPlannerView />
                    <RadzenYearTimelineView />
                </ChildContent>
                <NavigationTemplate>
                    <RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" Gap="0.5rem" Style="margin-bottom: 1rem;">
                        <RadzenButton Text="Month" Click="@(() => ChangeView(0))"
                                    ButtonStyle="@(_selectedViewIndex == 0 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                        <RadzenButton Text="Week" Click="@(() => ChangeView(1))"
                                    ButtonStyle="@(_selectedViewIndex == 1 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                        <RadzenButton Text="Day" Click="@(() => ChangeView(2))"
                                    ButtonStyle="@(_selectedViewIndex == 2 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                        <RadzenButton Text="Year" Click="@(() => ChangeView(3))"
                                    ButtonStyle="@(_selectedViewIndex == 3 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                        <RadzenButton Text="Planner" Click="@(() => ChangeView(4))"
                                    ButtonStyle="@(_selectedViewIndex == 4 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                        <RadzenButton Text="Timeline" Click="@(() => ChangeView(5))"
                                    ButtonStyle="@(_selectedViewIndex == 5 ? ButtonStyle.Primary : ButtonStyle.Light)"
                                    Size="ButtonSize.Small" />
                    </RadzenStack>
                </NavigationTemplate>
            </RadzenScheduler>
                }
            </RadzenCard>
        }
    </div>
</div>

</div>

<!-- Quick Edit Popover -->
<QuickEditEventPopover @ref="_quickEditPopover"
                       OnSaved="OnQuickEditSaved"
                       OnFullDialogRequested="OnFullDialogRequested" />

@code {
    // Appointment wrapper class for RadzenScheduler
    public class AppointmentData
    {
        public DateTime Start { get; set; }
        public DateTime End { get; set; }
        public string Text { get; set; } = string.Empty;
        public Event? Event { get; set; } // Nullable for team member events
        public bool IsReadOnly { get; set; } // True for team member events
    }

    // State variables
    private DateTime _selectedDate = DateTime.Today;
    private List<Event> _events = new();
    private List<AppointmentData> _appointments = new();
    private bool _loading = true;
    private CalendarSettings? _settings;
    private string _userId = string.Empty;
    private string _userEmail = string.Empty;
    private string _userTimeZone = TimeZoneInfo.Local.Id;
    private RadzenScheduler<AppointmentData>? _scheduler;
    private int _selectedViewIndex = 1; // Default to Week view (index 1)
    private bool _isSearchActive = false;
    private QuickEditEventPopover? _quickEditPopover;
    private Event? _pendingEventForFullDialog;
    private List<Event> _allEvents = new(); // Store all events when search is active

    // Calendar management
    private List<Tempus.Core.Models.Calendar> _calendars = new();
    private List<CalendarShare> _sharedCalendars = new();

    // Team member calendar comparison
    private List<TeamMember> _teamMembers = new();
    private HashSet<string> _selectedTeamMemberIds = new();
    private Dictionary<string, List<Event>> _teamMemberEvents = new();

    // Bulk operations
    private bool _selectionMode = false;
    private HashSet<Guid> _selectedEventIds = new();

    // Helper classes
    private CalendarEventManager? _eventManager;
    private CalendarDragDropManager? _dragDropManager;
    private CalendarFormatter? _formatter;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var appUser = await IdentityUserAccessor.GetUserAsync(user);
            if (appUser != null)
            {
                _userId = appUser.Id;
                _userEmail = appUser.Email ?? "";

                // Get timezone from user settings, or fallback to system/browser timezone
                _userTimeZone = !string.IsNullOrEmpty(appUser.TimeZone)
                    ? appUser.TimeZone
                    : TimeZoneInfo.Local.Id;

                Logger.LogDebug("User ID: {UserId}", _userId);
                Logger.LogDebug("User timezone: {UserTimeZone}", _userTimeZone);

                _settings = await SettingsService.GetOrCreateDefaultSettingsAsync(_userId);

                // Load saved view preference
                // If RememberLastView is enabled and there's a LastUsedView, use it; otherwise use DefaultCalendarView
                var viewToLoad = _settings.RememberLastView && _settings.LastUsedView.HasValue
                    ? _settings.LastUsedView.Value
                    : _settings.DefaultCalendarView;

                _selectedViewIndex = GetSchedulerIndexFromCalendarView(viewToLoad);

                // Load user's calendars
                await CalendarRepository.EnsureDefaultCalendarExistsAsync(_userId, _userEmail);
                _calendars = await CalendarRepository.GetAllAsync(_userId);
                Logger.LogDebug("Loaded {CalendarCount} owned calendars", _calendars.Count);

                // Load shared calendars (only accepted shares)
                _sharedCalendars = await CalendarSharingService.GetCalendarsSharedWithUserAsync(_userId, includeUnaccepted: false);
                Logger.LogDebug("Loaded {SharedCalendarCount} shared calendars", _sharedCalendars.Count);

                // Load team members for calendar comparison
                await LoadTeamMembers();
            }
        }

        // Initialize helper classes
        _eventManager = new CalendarEventManager(
            EventRepository, DialogService, EmailNotificationService,
            AuthenticationStateProvider, IdentityUserAccessor);
        _dragDropManager = new CalendarDragDropManager(DialogService, _eventManager);
        _formatter = new CalendarFormatter(_settings);

        Logger.LogDebug("Initialization complete. User ID: {UserId}", _userId);

        // Load initial events as fallback if OnLoadData doesn't trigger
        // OnLoadData should override this once scheduler is ready
        await LoadInitialEvents();
    }

    private async Task LoadInitialEvents()
    {
        Logger.LogDebug("Loading initial events...");
        try
        {
            // Load events for current month +/- 1 month
            var startDate = DateTime.Today.AddMonths(-1);
            var endDate = DateTime.Today.AddMonths(2);

            Logger.LogDebug("Date range: {StartDate:yyyy-MM-dd} to {EndDate:yyyy-MM-dd}", startDate, endDate);
            Logger.LogDebug("User ID: {UserId}", _userId);

            // Load user's own events
            var ownEvents = await EventRepository.GetEventsByDateRangeAsync(startDate, endDate, _userId);
            Logger.LogDebug("Loaded {OwnEventCount} owned events", ownEvents.Count);

            // Load events from shared calendars
            var sharedCalendarIds = _sharedCalendars.Select(sc => sc.CalendarId).ToList();
            var sharedEvents = new List<Event>();
            if (sharedCalendarIds.Any())
            {
                sharedEvents = await EventRepository.GetEventsByDateRangeAndCalendarsAsync(startDate, endDate, sharedCalendarIds);
                Logger.LogDebug("Loaded {SharedEventCount} shared calendar events", sharedEvents.Count);
            }

            // Combine both lists
            _events = ownEvents.Concat(sharedEvents).OrderBy(e => e.StartTime).ToList();
            Logger.LogDebug("Loaded {EventCount} total events", _events.Count);

            ConvertEventsToAppointments();

            _loading = false;
            StateHasChanged();

            Logger.LogDebug("Complete. Appointments: {AppointmentCount}", _appointments.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ERROR loading initial events");
            _loading = false;
            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            // Scroll to the current time when the component is first rendered
            // Longer delay to ensure Radzen scheduler is fully rendered
            await Task.Delay(1000);

            var now = DateTime.Now;
            var hour = now.Hour;
            var minute = now.Minute;

            // Calculate scroll position: 60px per hour
            var scrollPosition = (hour * 60 + minute) - 180; // Offset by 3 hours (180 minutes)
            scrollPosition = Math.Max(0, scrollPosition);

            Logger.LogInformation("Scrolling calendar to current time: {Hour}:{Minute:00}, position: {Position}px",
                hour, minute, scrollPosition);

            try
            {
                await JSRuntime.InvokeVoidAsync("scrollSchedulerToTime", scrollPosition);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to invoke scrollSchedulerToTime");
            }
        }
    }

    private async Task OnLoadData(SchedulerLoadDataEventArgs args)
    {
        Logger.LogDebug("=== CALLED ===");
        Logger.LogDebug("args.Start: {ArgsStart:yyyy-MM-dd HH:mm:ss} (Kind: {Kind})", args.Start, args.Start.Kind);
        Logger.LogDebug("args.End: {ArgsEnd:yyyy-MM-dd HH:mm:ss} (Kind: {Kind})", args.End, args.End.Kind);
        Logger.LogDebug("User timezone: {UserTimeZone}", _userTimeZone);
        Logger.LogDebug("User ID: {UserId}", _userId);

        try
        {
            // CRITICAL FIX: Convert date range from user's timezone to UTC for querying
            // args.Start/End are date values that represent dates in the user's view
            // We treat them as being in the user's configured timezone, then convert to UTC
            //
            // Example: User in EST viewing Nov 9
            //   - args.Start = Nov 9 00:00 (treated as EST)
            //   - Converts to Nov 9 05:00 UTC
            //   - User creates event at 11:00 PM EST Nov 8 = 04:00 UTC Nov 9
            //   - Without expansion, this event would be missed!
            //
            // Solution: Expand range by Â±1 day, then convert to UTC using user's timezone

            // Expand by 1 day on each side to catch timezone edge cases
            var startLocal = args.Start.Date.AddDays(-1);
            var endLocal = args.End.Date.AddDays(1);

            // Treat these dates as being in the user's timezone and convert to UTC
            var startUtc = TimeZoneConversionService.ConvertTime(
                DateTime.SpecifyKind(startLocal, DateTimeKind.Unspecified),
                _userTimeZone,
                "UTC"
            );
            var endUtc = TimeZoneConversionService.ConvertTime(
                DateTime.SpecifyKind(endLocal, DateTimeKind.Unspecified),
                _userTimeZone,
                "UTC"
            );

            Logger.LogDebug("User timezone range - Start: {StartLocal:yyyy-MM-dd}, End: {EndLocal:yyyy-MM-dd}", startLocal, endLocal);
            Logger.LogDebug("Converted to UTC - Start: {StartUtc:yyyy-MM-dd HH:mm:ss}, End: {EndUtc:yyyy-MM-dd HH:mm:ss}", startUtc, endUtc);

            // Load user's own events
            var ownEvents = await EventRepository.GetEventsByDateRangeAsync(startUtc, endUtc, _userId);
            Logger.LogDebug("Loaded {OwnEventCount} owned events", ownEvents.Count);

            // Load events from shared calendars
            var sharedCalendarIds = _sharedCalendars.Select(sc => sc.CalendarId).ToList();
            var sharedEvents = new List<Event>();
            if (sharedCalendarIds.Any())
            {
                sharedEvents = await EventRepository.GetEventsByDateRangeAndCalendarsAsync(startUtc, endUtc, sharedCalendarIds);
                Logger.LogDebug("Loaded {SharedEventCount} shared calendar events", sharedEvents.Count);
            }

            // Load events from selected team members
            if (_selectedTeamMemberIds.Any())
            {
                _teamMemberEvents.Clear();
                foreach (var userId in _selectedTeamMemberIds)
                {
                    var memberEvents = await EventRepository.GetEventsByDateRangeAsync(startUtc, endUtc, userId);
                    _teamMemberEvents[userId] = memberEvents;
                    Logger.LogDebug("Loaded {MemberEventCount} events for team member {UserId}", memberEvents.Count, userId);
                }
            }

            // Combine both lists
            _events = ownEvents.Concat(sharedEvents).OrderBy(e => e.StartTime).ToList();
            Logger.LogDebug("Loaded {EventCount} total events", _events.Count);
            if (_events.Any())
            {
                var minDate = _events.Min(e => e.StartTime);
                var maxDate = _events.Max(e => e.StartTime);
                Logger.LogDebug("Event date range: {MinDate:yyyy-MM-dd} to {MaxDate:yyyy-MM-dd}", minDate, maxDate);
            }

            ConvertEventsToAppointments();
            Logger.LogDebug("Converted to {AppointmentCount} appointments", _appointments.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ERROR in OnLoadData");

            // Set empty appointments on error
            _appointments = new List<AppointmentData>();
            _events = new List<Event>();
        }

        Logger.LogDebug("=== COMPLETE ===");
    }

    private async Task LoadEvents()
    {
        Logger.LogDebug("Reloading events...");

        // Trigger the scheduler to reload data for the current visible date range
        // This will call OnLoadData with the appropriate date range
        if (_scheduler != null)
        {
            Logger.LogDebug("Calling scheduler.Reload()");
            await _scheduler.Reload();
        }
        else
        {
            Logger.LogDebug("Scheduler not ready, using LoadInitialEvents");
            await LoadInitialEvents();
        }
    }

    private void ConvertEventsToAppointments()
    {
        // Convert events to appointments for RadzenScheduler
        // All events are stored in UTC, so always convert to user's timezone for display
        // Filter events by calendar visibility

        // Combine visible calendar IDs from owned and shared calendars
        var visibleOwnedCalendarIds = _calendars
            .Where(c => c.IsVisible)
            .Select(c => c.Id);

        var visibleSharedCalendarIds = _sharedCalendars
            .Where(sc => sc.IsVisible)
            .Select(sc => sc.CalendarId);

        var visibleCalendarIds = visibleOwnedCalendarIds
            .Concat(visibleSharedCalendarIds)
            .ToHashSet();

        // Convert owned/shared calendar events
        var ownAppointments = _events
            .Where(e => !e.CalendarId.HasValue || visibleCalendarIds.Contains(e.CalendarId.Value))
            .Select(e => ConvertEventToAppointment(e, isOwn: true))
            .ToList();

        // Convert team member events
        var teamAppointments = _teamMemberEvents
            .Where(kvp => _selectedTeamMemberIds.Contains(kvp.Key))
            .SelectMany(kvp => kvp.Value.Select(e => ConvertEventToAppointment(e, isOwn: false)))
            .ToList();

        _appointments = ownAppointments.Concat(teamAppointments).ToList();
    }

    private AppointmentData ConvertEventToAppointment(Event e, bool isOwn)
    {
        // CRITICAL FIX: Events from database may have DateTimeKind.Unspecified
        // We need to explicitly mark them as UTC since we store everything in UTC
        if (e.StartTime.Kind == DateTimeKind.Unspecified && e.TimeZoneId == "UTC")
        {
            e.StartTime = DateTime.SpecifyKind(e.StartTime, DateTimeKind.Utc);
            e.EndTime = DateTime.SpecifyKind(e.EndTime, DateTimeKind.Utc);
        }

        var displayEvent = e;

        // Convert from UTC to user's timezone for display
        // Events are always stored in UTC (TimeZoneId = "UTC")
        if (!string.IsNullOrEmpty(e.TimeZoneId))
        {
            displayEvent = TimeZoneConversionService.ConvertEventToUserTimeZone(e, _userTimeZone);
        }

        // Filter private events for team members (non-own events)
        var displayTitle = (!isOwn && e.IsPrivate) ? "Private Appointment" : displayEvent.Title;

        return new AppointmentData
        {
            Start = displayEvent.StartTime,
            End = displayEvent.EndTime,
            Text = displayTitle,
            Event = isOwn ? e : null, // Only set Event for own events (allows editing)
            IsReadOnly = !isOwn // Team member events are read-only
        };
    }

    private async Task DownloadDailyAgenda()
    {
        try
        {
            // Get events for the selected date
            var eventsForDay = GetEventsForDay(_selectedDate);

            // Get user name
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            var userName = "User";
            if (user.Identity?.IsAuthenticated == true)
            {
                var appUser = await IdentityUserAccessor.GetUserAsync(user);
                if (appUser != null)
                {
                    userName = $"{appUser.FirstName} {appUser.LastName}".Trim();
                    if (string.IsNullOrWhiteSpace(userName))
                    {
                        userName = appUser.Email ?? "User";
                    }
                }
            }

            // Generate PDF
            var pdfBytes = PdfAgendaService.GenerateDailyAgenda(eventsForDay, _selectedDate, userName);

            // Download file using inline JavaScript to avoid timing issues
            var fileName = $"Daily-Agenda-{_selectedDate:yyyy-MM-dd}.pdf";
            var base64 = Convert.ToBase64String(pdfBytes);

            await JSRuntime.InvokeVoidAsync("eval", $@"
                (function() {{
                    const byteCharacters = atob('{base64}');
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {{
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }}
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], {{ type: 'application/pdf' }});
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = '{fileName}';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                }})();
            ");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error generating PDF");
        }
    }

    private List<Event> GetEventsForDay(DateTime date)
    {
        return _events
            .Where(e => e.StartTime.Date == date.Date)
            .OrderBy(e => e.StartTime)
            .ToList();
    }


    private async Task OnAppointmentSelect(SchedulerAppointmentSelectEventArgs<AppointmentData> args)
    {
        var appointment = args.Data;

        // Prevent interaction with read-only team member events
        if (appointment?.IsReadOnly == true)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Read-Only Event",
                Detail = "This is a team member's event and cannot be edited",
                Duration = 2000
            });
            return;
        }

        if (appointment?.Event != null)
        {
            // Check if user has permission to view details
            var canViewDetails = true;
            if (appointment.Event.CalendarId.HasValue)
            {
                var share = _sharedCalendars.FirstOrDefault(sc => sc.CalendarId == appointment.Event.CalendarId.Value);
                if (share != null && !share.CanViewDetails())
                {
                    canViewDetails = false;
                    NotificationService.Notify(new NotificationMessage
                    {
                        Severity = NotificationSeverity.Info,
                        Summary = "Limited Access",
                        Detail = "You can only see free/busy information for this calendar",
                        Duration = 3000
                    });
                }
            }

            if (canViewDetails)
            {
                // If in selection mode, toggle selection instead of opening dialog
                if (_selectionMode)
                {
                    ToggleEventSelection(appointment.Event.Id);
                }
                else
                {
                    // Show quick edit popover for single click
                    // Position at center of screen (we can enhance this later with JS interop for mouse position)
                    if (_quickEditPopover != null)
                    {
                        _pendingEventForFullDialog = appointment.Event;
                        await _quickEditPopover.ShowAsync(appointment.Event, 400, 200);
                    }
                }
            }
        }
    }

    private async Task OnSlotSelect(SchedulerSlotSelectEventArgs args)
    {
        await OpenEventDialogAsync(null, args.Start);
    }

    private void OnSlotRender(SchedulerSlotRenderEventArgs args)
    {
        // Shade non-working hours (before 9 AM and after 5 PM)
        var hour = args.Start.Hour;
        if (hour < 9 || hour >= 17)
        {
            args.Attributes["class"] = "non-working-hours";
        }
    }

    private async Task OnQuickEditSaved(bool saved)
    {
        if (saved)
        {
            // Reload events to show updated data
            await LoadEvents();
        }
    }

    private async Task OnFullDialogRequested()
    {
        if (_pendingEventForFullDialog != null)
        {
            var eventId = _pendingEventForFullDialog.RecurrenceParentId ?? _pendingEventForFullDialog.Id;
            await OpenEventDialogAsync(eventId);
            _pendingEventForFullDialog = null;
        }
    }

    private void OnAppointmentRender(SchedulerAppointmentRenderEventArgs<AppointmentData> args)
    {
        var evt = args.Data.Event;
        if (evt != null && _formatter != null)
        {
            // Check if event is selected
            var isSelected = _selectedEventIds.Contains(evt.Id);

            // Check if this is a shared calendar event and get permission level
            var share = evt.CalendarId.HasValue
                ? _sharedCalendars.FirstOrDefault(sc => sc.CalendarId == evt.CalendarId.Value)
                : null;
            var isFreeBusyOnly = share != null && share.Permission == CalendarSharePermission.FreeBusyOnly;

            // Get calendar color for border - check both owned and shared calendars
            var calendarColor = evt.CalendarId.HasValue
                ? (_calendars.FirstOrDefault(c => c.Id == evt.CalendarId.Value)?.Color
                   ?? _sharedCalendars.FirstOrDefault(sc => sc.CalendarId == evt.CalendarId.Value)?.Color
                   ?? _sharedCalendars.FirstOrDefault(sc => sc.CalendarId == evt.CalendarId.Value)?.Calendar?.Color
                   ?? "#757575") // Default gray if no calendar
                : "#757575"; // Default gray if no calendar

            // Get event's own color for background (from booking page, category, or custom)
            var backgroundColor = _formatter.GetEventBackgroundColor(evt);

            // Add selection styling if selected
            if (isSelected)
            {
                args.Attributes["style"] = $"background-color: {backgroundColor}; border: 3px solid #FFD700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);";
            }
            else
            {
                args.Attributes["style"] = $"background-color: {backgroundColor}; border-left: 5px solid {calendarColor};";
            }

            // For FreeBusyOnly permission, show "Busy" instead of event details
            if (isFreeBusyOnly)
            {
                args.Data.Text = "ðŸ”’ Busy";
            }
            else
            {
                // Add icon based on event type
                var icon = _formatter.GetEventIcon(evt.EventType);

                // Add selection indicator
                var selectionIndicator = isSelected ? "âœ“ " : "";

                // Add timezone indicator if event is in a different timezone
                var timeZoneIndicator = "";
                if (!string.IsNullOrEmpty(evt.TimeZoneId) && evt.TimeZoneId != _userTimeZone)
                {
                    try
                    {
                        var tz = TimeZoneInfo.FindSystemTimeZoneById(evt.TimeZoneId);
                        var abbreviation = GetTimeZoneAbbreviation(tz);
                        timeZoneIndicator = $" ðŸŒ {abbreviation}";
                    }
                    catch
                    {
                        timeZoneIndicator = " ðŸŒ";
                    }
                }

                args.Data.Text = $"{selectionIndicator}{icon} {evt.Title}{timeZoneIndicator}";
            }
        }

        // Add context menu to appointment (but only for events user can view)
        if (evt != null)
        {
            var canViewDetails = evt.CalendarId.HasValue
                ? (_calendars.Any(c => c.Id == evt.CalendarId.Value) || // User owns the calendar
                   _sharedCalendars.FirstOrDefault(sc => sc.CalendarId == evt.CalendarId.Value)?.CanViewDetails() == true)
                : true;

            if (canViewDetails)
            {
                args.Attributes["oncontextmenu"] = (MouseEventArgs mouseArgs) =>
                {
                    ShowContextMenu(mouseArgs, args.Data);
                };
            }
        }
    }

    private string GetTimeZoneAbbreviation(TimeZoneInfo tz)
    {
        var abbreviation = tz.IsDaylightSavingTime(DateTime.Now)
            ? tz.DaylightName
            : tz.StandardName;

        // Try to get a shorter abbreviation
        if (abbreviation.Contains("Standard") || abbreviation.Contains("Daylight"))
        {
            var words = abbreviation.Split(' ');
            if (words.Length > 1)
            {
                abbreviation = string.Join("", words.Select(w => char.IsLetter(w.FirstOrDefault()) ? w.First() : ' ')).Trim();
            }
        }

        // If abbreviation is still long, use UTC offset instead
        if (abbreviation.Length > 5)
        {
            abbreviation = $"UTC{tz.BaseUtcOffset:hh\\:mm}";
        }

        return abbreviation;
    }


    private async Task OpenEventDialogAsync(Guid? eventId, DateTime? prefilledDate = null)
    {
        if (_eventManager != null)
        {
            var saved = await _eventManager.OpenEventDialogAsync(eventId, prefilledDate);
            if (saved)
            {
                await LoadEvents();
            }
        }
    }

    private async Task EditSingleOccurrenceAsync(Event instance)
    {
        if (_eventManager != null)
        {
            var saved = await _eventManager.EditSingleOccurrenceAsync(instance);
            if (saved)
            {
                await LoadEvents();
            }
        }
    }

    private async Task DeleteSingleOccurrenceAsync(Event instance)
    {
        if (_eventManager != null)
        {
            var deleted = await _eventManager.DeleteSingleOccurrenceAsync(instance, _userId);
            if (deleted)
            {
                await LoadEvents();
            }
        }
    }

    private async Task DeleteEventAsync(Guid id)
    {
        if (_eventManager != null)
        {
            var deleted = await _eventManager.DeleteEventAsync(id, _userId);
            if (deleted)
            {
                await LoadEvents();
            }
        }
    }

    // Event Icon Mapping
    private string GetEventIcon(Core.Enums.EventType eventType)
    {
        return _formatter?.GetEventIcon(eventType) ?? "ðŸ“Œ";
    }

    // Template Creation
    private async Task CreateFromTemplate(string templateName, int durationMinutes)
    {
        if (_eventManager != null)
        {
            await _eventManager.CreateFromTemplateAsync(templateName, durationMinutes, _selectedDate, _settings, _userId);
            await LoadEvents();
            StateHasChanged();
        }
    }

    // AppointmentMove - handles drag and drop using RadzenScheduler's built-in functionality
    private async Task OnAppointmentMove(SchedulerAppointmentMoveEventArgs args)
    {
        if (_dragDropManager == null) return;

        try
        {
            var appointment = (AppointmentData)args.Appointment.Data;
            var evt = appointment?.Event;

            if (evt == null || appointment == null) return;

            // Calculate new start and end times
            var newStartTime = evt.StartTime + args.TimeSpan;
            var newEndTime = evt.EndTime + args.TimeSpan;

            // Handle recurring events with confirmation dialog
            await _dragDropManager.HandleEventDropAsync(
                evt,
                newStartTime,
                newEndTime,
                _userId,
                async () =>
                {
                    // Update the appointment data immediately for UI responsiveness
                    appointment.Start = newStartTime;
                    appointment.End = newEndTime;

                    // Reload events from database
                    await LoadEvents();

                    // Reload the scheduler
                    if (_scheduler != null)
                    {
                        await _scheduler.Reload();
                    }
                });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in OnAppointmentMove");
        }
    }


    // Context Menu
    private void ShowContextMenu(MouseEventArgs args, AppointmentData data)
    {
        var evt = data.Event;
        if (evt == null) return;

        var menuItems = new List<ContextMenuItem>();

        // Add selection option if in selection mode
        if (_selectionMode)
        {
            var isSelected = _selectedEventIds.Contains(evt.Id);
            menuItems.Add(new ContextMenuItem
            {
                Text = isSelected ? "Deselect" : "Select",
                Value = data,
                Icon = isSelected ? "check_box_outline_blank" : "check_box"
            });
        }
        else
        {
            // For recurring events, show options for both single occurrence and series
            if (evt.IsRecurring || evt.RecurrenceParentId.HasValue)
            {
                menuItems.Add(new ContextMenuItem { Text = "Edit This Occurrence", Value = data, Icon = "edit" });
                menuItems.Add(new ContextMenuItem { Text = "Edit Series", Value = data, Icon = "event_repeat" });
                menuItems.Add(new ContextMenuItem { Text = "Duplicate", Value = data, Icon = "content_copy" });
                menuItems.Add(new ContextMenuItem { Text = "Delete This Occurrence", Value = data, Icon = "delete_outline" });
                menuItems.Add(new ContextMenuItem { Text = "Delete Series", Value = data, Icon = "delete_forever" });
            }
            else
            {
                // For non-recurring events, show standard options
                menuItems.Add(new ContextMenuItem { Text = "Edit", Value = data, Icon = "edit" });
                menuItems.Add(new ContextMenuItem { Text = "Duplicate", Value = data, Icon = "content_copy" });
                menuItems.Add(new ContextMenuItem { Text = "Delete", Value = data, Icon = "delete" });
            }
        }

        ContextMenuService.Open(args, menuItems, OnMenuItemClick);
    }

    private async void OnMenuItemClick(MenuItemEventArgs item)
    {
        ContextMenuService.Close();

        var data = item.Value as AppointmentData;
        if (data?.Event == null) return;

        switch (item.Text)
        {
            case "Select":
            case "Deselect":
                ToggleEventSelection(data.Event.Id);
                break;

            case "Edit":
                // For non-recurring events
                await OpenEventDialogAsync(data.Event.Id);
                break;

            case "Edit This Occurrence":
                // For recurring events, edit only this occurrence
                await EditSingleOccurrenceAsync(data.Event);
                break;

            case "Edit Series":
                // For recurring events, edit the parent event (all occurrences)
                var eventIdToEdit = data.Event.RecurrenceParentId ?? data.Event.Id;
                await OpenEventDialogAsync(eventIdToEdit);
                break;

            case "Duplicate":
                await DuplicateEventAsync(data.Event);
                break;

            case "Delete":
                // For non-recurring events
                await DeleteEventAsync(data.Event.Id);
                break;

            case "Delete This Occurrence":
                // For recurring events, delete only this occurrence
                await DeleteSingleOccurrenceAsync(data.Event);
                break;

            case "Delete Series":
                // For recurring events, delete the parent event (all occurrences)
                var eventIdToDelete = data.Event.RecurrenceParentId ?? data.Event.Id;
                await DeleteEventAsync(eventIdToDelete);
                break;
        }
    }

    private async Task DuplicateEventAsync(Event originalEvent)
    {
        try
        {
            // Create a duplicate of the event
            var duplicateEvent = new Event
            {
                Id = Guid.NewGuid(),
                Title = $"{originalEvent.Title} (Copy)",
                Description = originalEvent.Description,
                StartTime = originalEvent.StartTime,
                EndTime = originalEvent.EndTime,
                Location = originalEvent.Location,
                EventType = originalEvent.EventType,
                Priority = originalEvent.Priority,
                Color = originalEvent.Color,
                UserId = _userId,
                IsAllDay = originalEvent.IsAllDay,
                IsRecurring = false, // Don't duplicate recurrence
                RecurrencePattern = RecurrencePattern.None,
                RecurrenceEndDate = null,
                RecurrenceParentId = null,
                IsRecurrenceException = false,
                RecurrenceExceptionDate = null,
                Tags = new List<string>(originalEvent.Tags),
                Attendees = new List<Attendee>(originalEvent.Attendees.Select(a => new Attendee
                {
                    Id = Guid.NewGuid(),
                    Name = a.Name,
                    Email = a.Email,
                    EventId = Guid.Empty // Will be set when saved
                })),
                CreatedAt = DateTime.UtcNow,
                HourlyCostPerAttendee = originalEvent.HourlyCostPerAttendee,
                MeetingCost = originalEvent.MeetingCost
            };

            await EventRepository.CreateAsync(duplicateEvent);
            await LoadEvents();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error duplicating event");
        }
    }

    // View management
    private async Task ChangeView(int newIndex)
    {
        _selectedViewIndex = newIndex;

        // Use JSRuntime to log to browser console
        await JSRuntime.InvokeVoidAsync("console.log", $"[Calendar ChangeView] Changing view to index: {newIndex}");

        // Save the selected view to settings
        if (_settings != null)
        {
            var newView = GetCalendarViewFromSchedulerIndex(newIndex);

            // Update last used view if RememberLastView is enabled
            if (_settings.RememberLastView)
            {
                _settings.LastUsedView = newView;
                _settings.LastViewChangeDate = DateTime.UtcNow;
            }

            // Also update default view
            _settings.DefaultCalendarView = newView;
            _settings.UpdatedAt = DateTime.UtcNow;

            await JSRuntime.InvokeVoidAsync("console.log", $"[Calendar ChangeView] Saving view preference: {newView}");

            try
            {
                var savedSettings = await SettingsService.CreateOrUpdateSettingsAsync(_settings);
                await JSRuntime.InvokeVoidAsync("console.log", $"[Calendar ChangeView] Saved successfully. DefaultCalendarView: {savedSettings.DefaultCalendarView}, LastUsedView: {savedSettings.LastUsedView}");
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", $"[Calendar ChangeView] Error saving: {ex.Message}");
            }
        }

        StateHasChanged();
    }

    private int GetSchedulerIndexFromCalendarView(CalendarView view)
    {
        return view switch
        {
            CalendarView.Month => 0,         // RadzenMonthView
            CalendarView.Week => 1,          // RadzenWeekView
            CalendarView.Day => 2,           // RadzenDayView
            CalendarView.Year => 3,          // RadzenYearView
            CalendarView.YearPlanner => 4,   // RadzenYearPlannerView
            CalendarView.YearTimeline => 5,  // RadzenYearTimelineView
            CalendarView.WorkWeek => 1,      // RadzenWeekView (no separate WorkWeek view in scheduler)
            _ => 1                           // Default to Week
        };
    }

    private CalendarView GetCalendarViewFromSchedulerIndex(int index)
    {
        return index switch
        {
            0 => CalendarView.Month,         // RadzenMonthView
            1 => CalendarView.Week,          // RadzenWeekView
            2 => CalendarView.Day,           // RadzenDayView
            3 => CalendarView.Year,          // RadzenYearView
            4 => CalendarView.YearPlanner,   // RadzenYearPlannerView
            5 => CalendarView.YearTimeline,  // RadzenYearTimelineView
            _ => CalendarView.Week        // Default to Week
        };
    }

    // Advanced Search
    private async Task OpenAdvancedSearch()
    {
        var result = await DialogService.OpenAsync<AdvancedSearchDialog>("Advanced Search",
            new Dictionary<string, object>(),
            new DialogOptions() { Width = "700px", Height = "600px", Resizable = true, Draggable = true });

        if (result is AdvancedSearchFilter filter)
        {
            await PerformSearch(filter);
        }
    }

    private async Task PerformSearch(AdvancedSearchFilter filter)
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Store all events if this is the first search
            if (!_isSearchActive)
            {
                _allEvents = new List<Event>(_events);
            }

            // Perform the search
            var searchResults = await EventRepository.AdvancedSearchAsync(filter, _userId);

            // Update the events list with search results
            _events = searchResults;

            // Convert search results to appointments
            _appointments = _events.Select(e =>
            {
                var displayEvent = e;

                // If event has a timezone different from user's, convert it
                if (!string.IsNullOrEmpty(e.TimeZoneId) && e.TimeZoneId != _userTimeZone)
                {
                    displayEvent = TimeZoneConversionService.ConvertEventToUserTimeZone(e, _userTimeZone);
                }

                return new AppointmentData
                {
                    Start = displayEvent.StartTime,
                    End = displayEvent.EndTime,
                    Text = displayEvent.Title,
                    Event = e
                };
            }).ToList();

            _isSearchActive = true;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error performing search");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task ClearSearch()
    {
        _loading = true;
        StateHasChanged();

        // Restore all events
        if (_allEvents.Any())
        {
            _events = new List<Event>(_allEvents);
        }
        else
        {
            // If no stored events, reload from database
            await LoadEvents();
        }

        // Convert back to appointments
        _appointments = _events.Select(e =>
        {
            var displayEvent = e;

            // If event has a timezone different from user's, convert it
            if (!string.IsNullOrEmpty(e.TimeZoneId) && e.TimeZoneId != _userTimeZone)
            {
                displayEvent = TimeZoneConversionService.ConvertEventToUserTimeZone(e, _userTimeZone);
            }

            return new AppointmentData
            {
                Start = displayEvent.StartTime,
                End = displayEvent.EndTime,
                Text = displayEvent.Title,
                Event = e
            };
        }).ToList();

        _isSearchActive = false;
        _allEvents.Clear();

        _loading = false;
        StateHasChanged();
    }

    // Bulk Operations
    private void ToggleSelectionMode()
    {
        _selectionMode = !_selectionMode;

        if (!_selectionMode)
        {
            // Clear selection when exiting selection mode
            _selectedEventIds.Clear();
        }

        StateHasChanged();
    }

    private void ToggleEventSelection(Guid eventId)
    {
        if (_selectedEventIds.Contains(eventId))
        {
            _selectedEventIds.Remove(eventId);
        }
        else
        {
            _selectedEventIds.Add(eventId);
        }

        StateHasChanged();
    }

    private void ClearSelection()
    {
        _selectedEventIds.Clear();
        StateHasChanged();
    }

    private async Task OpenBulkActionsDialog(string actionType)
    {
        var parameters = new Dictionary<string, object>
        {
            { "ActionType", actionType },
            { "SelectedCount", _selectedEventIds.Count }
        };

        var result = await DialogService.OpenAsync<BulkActionsDialog>($"Bulk {actionType.ToUpper()}",
            parameters,
            new DialogOptions() { Width = "500px", Height = "auto", Resizable = true, Draggable = true });

        if (result != null)
        {
            await ApplyBulkAction(actionType, result);
        }
    }

    private async Task ApplyBulkAction(string actionType, object value)
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var selectedIds = _selectedEventIds.ToList();
            int affectedCount = 0;

            switch (actionType)
            {
                case "type":
                    affectedCount = await EventRepository.BulkUpdateEventTypeAsync(selectedIds, (EventType)value, _userId);
                    break;

                case "priority":
                    affectedCount = await EventRepository.BulkUpdatePriorityAsync(selectedIds, (Priority)value, _userId);
                    break;

                case "color":
                    affectedCount = await EventRepository.BulkUpdateColorAsync(selectedIds, (string)value, _userId);
                    break;

                case "move":
                    affectedCount = await EventRepository.BulkMoveAsync(selectedIds, (TimeSpan)value, _userId);
                    break;
            }

            // Reload events
            await LoadEvents();

            // Clear selection
            _selectedEventIds.Clear();

            // Show success message
            Logger.LogInformation("Successfully updated {AffectedCount} event(s)", affectedCount);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error performing bulk action");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task BulkComplete(bool isCompleted)
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var selectedIds = _selectedEventIds.ToList();
            var affectedCount = await EventRepository.BulkCompleteAsync(selectedIds, isCompleted, _userId);

            // Reload events
            await LoadEvents();

            // Clear selection
            _selectedEventIds.Clear();

            Logger.LogInformation("Successfully marked {AffectedCount} event(s) as {Status}", affectedCount, isCompleted ? "complete" : "incomplete");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error marking events");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task ConfirmBulkDelete()
    {
        var confirmed = await DialogService.Confirm(
            $"Are you sure you want to delete {_selectedEventIds.Count} selected event(s)? This action cannot be undone.",
            "Confirm Bulk Delete",
            new ConfirmOptions() { OkButtonText = "Delete", CancelButtonText = "Cancel" });

        if (confirmed == true)
        {
            await BulkDelete();
        }
    }

    private async Task BulkDelete()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var selectedIds = _selectedEventIds.ToList();
            var affectedCount = await EventRepository.BulkDeleteAsync(selectedIds, _userId);

            // Reload events
            await LoadEvents();

            // Clear selection
            _selectedEventIds.Clear();

            Logger.LogInformation("Successfully deleted {AffectedCount} event(s)", affectedCount);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting events");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    // Calendar Management
    private async Task OpenCalendarManagement()
    {
        var result = await DialogService.OpenAsync<CalendarManagementDialog>("Manage Calendars",
            new Dictionary<string, object>
            {
                { "UserId", _userId },
                { "OnCalendarsChanged", EventCallback.Factory.Create(this, OnCalendarsChanged) }
            },
            new DialogOptions { Width = "700px", Height = "auto", Resizable = true, Draggable = true });
    }

    // Scheduling Assistant
    private async Task OpenFindTimeDialog()
    {
        var result = await DialogService.OpenAsync<FindTimeDialog>("Find Optimal Meeting Time",
            new Dictionary<string, object>(),
            new DialogOptions { Width = "850px", Height = "90vh", Resizable = true, Draggable = true });

        if (result != null)
        {
            // Result contains StartTime from FindTimeDialog selection
            // Open event dialog with pre-filled start time
            dynamic selection = result;
            await OpenEventDialogAsync(null, (DateTime)selection.StartTime);
        }
    }

    private async Task OnCalendarsChanged()
    {
        // Reload calendars
        _calendars = await CalendarRepository.GetAllAsync(_userId);

        // Refresh the calendar view
        ConvertEventsToAppointments();
        StateHasChanged();

        // Reload events to ensure any changes from calendar deletion are reflected
        await LoadEvents();
    }

    private async Task UpdateCalendarVisibility(Tempus.Core.Models.Calendar calendar, bool isVisible)
    {
        // The @bind-Value already updated calendar.IsVisible
        // We just need to save it and refresh the view
        await CalendarRepository.UpdateAsync(calendar);

        // Refresh the calendar view
        ConvertEventsToAppointments();
        StateHasChanged();

        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Calendar Visibility",
            Detail = $"{calendar.Name} is now {(isVisible ? "visible" : "hidden")}",
            Duration = 2000
        });
    }

    private async Task UpdateSharedCalendarVisibility(CalendarShare share, bool isVisible)
    {
        // The @bind-Value already updated share.IsVisible
        // We just need to save it and refresh the view
        await CalendarSharingService.UpdateShareVisibilityAsync(share.Id, isVisible, _userId);

        // Refresh the calendar view
        ConvertEventsToAppointments();
        StateHasChanged();

        var calendarName = share.Calendar?.Name ?? "Shared calendar";
        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Calendar Visibility",
            Detail = $"{calendarName} is now {(isVisible ? "visible" : "hidden")}",
            Duration = 2000
        });
    }

    private async Task LoadTeamMembers()
    {
        try
        {
            var teams = await TeamService.GetUserTeamsAsync(_userId);
            _teamMembers = teams
                .SelectMany(t => t.Members
                    .Where(m => m.UserId != _userId) // Exclude self
                    .Select(m => new TeamMember
                    {
                        Id = m.Id,
                        TeamId = t.Id,
                        Team = t,
                        UserId = m.UserId,
                        User = m.User,
                        Role = m.Role
                    }))
                .GroupBy(m => m.UserId)
                .Select(g => g.First()) // Remove duplicates if user is in multiple teams
                .OrderBy(m => m.User?.FirstName ?? m.User?.Email ?? "")
                .ToList();

            Logger.LogDebug("Loaded {TeamMemberCount} team members", _teamMembers.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading team members");
        }
    }

    private async Task ToggleTeamMemberSelection(string userId, bool isSelected)
    {
        if (isSelected)
        {
            _selectedTeamMemberIds.Add(userId);
        }
        else
        {
            _selectedTeamMemberIds.Remove(userId);
            _teamMemberEvents.Remove(userId);
        }

        // Reload calendar data for the current visible date range
        // This will trigger OnLoadData which loads team member events
        await LoadEvents();

        var member = _teamMembers.FirstOrDefault(m => m.UserId == userId);
        var memberName = $"{member?.User?.FirstName} {member?.User?.LastName}".Trim();
        if (string.IsNullOrWhiteSpace(memberName))
        {
            memberName = member?.User?.Email ?? "Team member";
        }

        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Team Member Calendar",
            Detail = $"{memberName}'s calendar is now {(isSelected ? "visible" : "hidden")}",
            Duration = 2000
        });
    }

    private string GetMemberDisplayName(TeamMember? member)
    {
        if (member?.User == null) return "Unknown";

        var displayName = $"{member.User.FirstName} {member.User.LastName}".Trim();
        if (string.IsNullOrWhiteSpace(displayName))
        {
            displayName = member.User.Email ?? "Unknown";
        }
        return displayName;
    }

    private List<AppointmentData> GetTeamMemberAppointments(string userId)
    {
        if (!_teamMemberEvents.TryGetValue(userId, out var events))
        {
            return new List<AppointmentData>();
        }

        return events.Select(e => ConvertEventToAppointment(e, isOwn: false)).ToList();
    }

    private async Task OnTeamMemberLoadData(SchedulerLoadDataEventArgs args, string userId)
    {
        Logger.LogDebug("Loading data for team member {UserId}", userId);

        try
        {
            // Convert date range from user's timezone to UTC (same logic as OnLoadData)
            var startLocal = args.Start.Date.AddDays(-1);
            var endLocal = args.End.Date.AddDays(1);

            var startUtc = TimeZoneConversionService.ConvertTime(
                DateTime.SpecifyKind(startLocal, DateTimeKind.Unspecified),
                _userTimeZone,
                "UTC"
            );
            var endUtc = TimeZoneConversionService.ConvertTime(
                DateTime.SpecifyKind(endLocal, DateTimeKind.Unspecified),
                _userTimeZone,
                "UTC"
            );

            var memberEvents = await EventRepository.GetEventsByDateRangeAsync(startUtc, endUtc, userId);
            _teamMemberEvents[userId] = memberEvents;
            Logger.LogDebug("Loaded {MemberEventCount} events for team member {UserId}", memberEvents.Count, userId);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading data for team member {UserId}", userId);
        }
    }

    private void OnTeamMemberAppointmentSelect(SchedulerAppointmentSelectEventArgs<AppointmentData> args)
    {
        // Team member events are read-only
        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Read-Only Event",
            Detail = "This is a team member's event and cannot be edited",
            Duration = 2000
        });
    }
}
